<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Models · JuMP</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-44252521-1', 'auto');
ga('send', 'pageview');
</script><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/highlightjs/default.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>JuMP</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Introduction</a></li><li><a class="toctext" href="installation.html">Installation Guide</a></li><li><a class="toctext" href="quickstart.html">Quick Start Guide</a></li><li class="current"><a class="toctext" href="refmodel.html">Models</a><ul class="internal"><li><a class="toctext" href="#Constructor-1">Constructor</a></li><li><a class="toctext" href="#Methods-1">Methods</a></li><li><a class="toctext" href="#Solve-Status-1">Solve Status</a></li><li><a class="toctext" href="#Quadratic-Objectives-1">Quadratic Objectives</a></li><li><a class="toctext" href="#Second-order-cone-constraints-1">Second-order cone constraints</a></li><li><a class="toctext" href="#Accessing-the-low-level-model-1">Accessing the low-level model</a></li></ul></li><li><a class="toctext" href="refvariable.html">Variables</a></li><li><a class="toctext" href="refexpr.html">Expressions and Constraints</a></li><li><a class="toctext" href="probmod.html">Problem Modification</a></li><li><a class="toctext" href="callbacks.html">Solver Callbacks</a></li><li><a class="toctext" href="nlp.html">Nonlinear Modeling</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="refmodel.html">Models</a></li></ul><a class="edit-page" href="https://github.com/JuliaOpt/JuMP.jl/tree/6d9b33dbac427d407b4fa800350db299896b2353/docs/src/refmodel.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Models</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Models-1" href="#Models-1">Models</a></h1><h2><a class="nav-anchor" id="Constructor-1" href="#Constructor-1">Constructor</a></h2><p><code>Model</code> is a type defined by JuMP. All variables and constraints are associated with a <code>Model</code> object. It has a constructor that has no required arguments:</p><pre><code class="language-none">m = Model()</code></pre><p>The constructor also accepts an optional keyword argument, <code>solver</code>. You may specify a solver either here or later on by calling <code>setsolver</code>. JuMP will throw an error if you try to solve a problem without specifying a solver.</p><p><code>solver</code> must be an <code>AbstractMathProgSolver</code> object, which is constructed as follows:</p><pre><code class="language-none">solver = solvername(Option1=Value1, Option2=Value2, ...)</code></pre><p>where <code>solvername</code> is one of the supported solvers. See the solver table &amp;lt;jump-solvertable&amp;gt; for the list of available solvers and corresponding parameter names. All options are solver-dependent; see corresponding solver packages for more information.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Be sure that the solver provided supports the problem class of the model. For example <code>ClpSolver</code> and <code>GLPKSolverLP</code> support only linear programming problems. <code>CbcSolver</code> and <code>GLPKSolverMIP</code> support only mixed-integer programming problems.</p></div></div><p>As an example, we can create a <code>Model</code> object that will use GLPK&#39;s exact solver for LPs as follows:</p><pre><code class="language-none">m = Model(solver = GLPKSolverLP(method=:Exact))</code></pre><h2><a class="nav-anchor" id="Methods-1" href="#Methods-1">Methods</a></h2><p><strong>General</strong></p><ul><li><p><code>MathProgBase.numvar(m::Model)</code> - returns the number of variables associated with the <code>Model m</code>.</p></li><li><p><code>MathProgBase.numlinconstr(m::Model)</code> - returns the number of linear constraints associated with the <code>Model m</code>.</p></li><li><p><code>MathProgBase.numquadconstr(m::Model)</code> - returns the number of quadratic constraints associated with the <code>Model m</code>.</p></li><li><p><code>JuMP.numsocconstr(m::Model)</code> - returns the number of second order cone constraints associated with the <code>Model m</code>.</p></li><li><p><code>JuMP.numsosconstr(m::Model)</code> - returns the number of sos constraints associated with the <code>Model m</code>.</p></li><li><p><code>JuMP.numsdconstr(m::Model)</code> - returns the number of semi-definite constraints associated with the <code>Model m</code>.</p></li><li><p><code>JuMP.numnlconstr(m::Model)</code> - returns the number of nonlinear constraints associated with the <code>Model m</code>.</p></li><li><p><code>MathProgBase.numconstr(m::Model)</code> - returns the total number of constraints associated with the <code>Model m</code>.</p></li><li><p><code>getsolvetime(m::Model)</code> - returns the solve time reported by the solver if it is implemented.</p></li><li><p><code>getnodecount(m::Model)</code> - returns the number of explored branch-and-bound nodes, if it is implemented.</p></li><li><p><code>getobjbound(m::Model)</code> - returns the best known bound on the optimal objective value. This is used, for example, when a branch-and-bound method is stopped before finishing.</p></li><li><p><code>getobjgap(m::Model)</code> - returns the final relative optimality gap as optimization terminated. That is, it returns <span>$\frac{|b-f|}{|f|}$</span>, where <em>b</em> is the best bound and <em>f</em> is the best feasible objective value.</p></li><li><p><code>getrawsolver(m::Model)</code> - returns an object that may be used to access a solver-specific API.</p></li><li><p><code>getsimplexiter(m::Model)</code> - returns the cumulative number of simplex iterations during the optimization process. In particular, for a MIP it returns the total simplex iterations for all nodes.</p></li><li><p><code>getbarrieriter(m::Model)</code> - returns the cumulative number of barrier iterations during the optimization process.</p></li><li><p><code>internalmodel(m::Model)</code> - returns the internal low-level <code>AbstractMathProgModel</code> object which can be used to access any functionality that is not exposed by JuMP. See the MathProgBase <a href="https://mathprogbasejl.readthedocs.org/en/latest/">documentation</a>.</p></li><li><p><code>solve(m::Model; suppress_warnings=false, relaxation=false)</code> - solves the model using the selected solver (or a default for the problem class), and takes two optional arguments that are disabled by default. Setting <code>suppress_warnings</code> to <code>true</code> will suppress all JuMP-specific output (e.g. warnings about infeasibility and lack of dual information) but will not suppress solver output (which should be done by passing options to the solver). Setting <code>relaxation=true</code> solves the standard continuous relaxation for the model: that is, integrality is dropped, special ordered set constraints are not enforced, and semi-continuous and semi-integer variables with bounds <code>[l,u]</code> are replaced with bounds <code>[min(l,0),max(u,0)]</code>.</p></li><li><p><code>JuMP.build(m::Model)</code> - builds the model in memory at the MathProgBase level without optimizing.</p></li><li><p><code>setsolver(m::Model,s::AbstractMathProgSolver)</code> - changes the solver which will be used for the next call to <code>solve()</code>, discarding the current internal model if present.</p></li><li><p><code>getindex(m::Model,name::Symbol)</code> - returns the variable, or group of variables, or constraint, or group of constraints, of the given name which were added to the model. This errors if multiple variables or constraints share the same name.</p></li><li><p><code>setindex!(m::Model, value, name::Symbol)</code> - stores the object <code>value</code> in the model <code>m</code> so that it can be accessed via <code>getindex</code>.</p></li></ul><p><strong>Objective</strong></p><ul><li><p><code>getobjective(m::Model)</code> - returns the objective function as a <code>QuadExpr</code>.</p></li><li><p><code>getobjectivesense(m::Model)</code> - returns objective sense, either <code>:Min</code> or <code>:Max</code>.</p></li><li><p><code>setobjectivesense(m::Model, newSense::Symbol)</code> - sets the objective sense (<code>newSense</code> is either <code>:Min</code> or <code>:Max</code>).</p></li><li><p><code>getobjectivevalue(m::Model)</code> - returns objective value after a call to <code>solve</code>.</p></li><li><p><code>getobjectivebound(m::Model)</code> - returns the best known bound on the optimal objective value after a call to <code>solve</code>.</p></li></ul><p><strong>Output</strong></p><ul><li><p><code>writeLP(m::Model, filename::AbstractString; genericnames=true)</code> - write the model to <code>filename</code> in the LP file format. Set <code>genericnames=false</code> for user-defined variable names.</p></li><li><p><code>writeMPS(m::Model, filename::AbstractString)</code> - write the model to <code>filename</code> in the MPS file format.</p></li></ul><h2><a class="nav-anchor" id="Solve-Status-1" href="#Solve-Status-1">Solve Status</a></h2><p>The call <code>status = solve(m)</code> returns a symbol recording the status of the optimization process, as reported by the solver. Typical values are listed in the table below, although the code can take solver-dependent values. For instance, certain solvers prove infeasibility or unboundedness during presolve, but do not report which of the two cases holds. See your solver interface documentation (as linked to in the solver table &amp;lt;jump-solvertable&amp;gt;) for more information.</p><table><tr><th>Status</th><th>Meaning</th></tr><tr><td><code>:Optimal</code></td><td>Problem solved to optimality</td></tr><tr><td><code>:Unbounded</code></td><td>Problem is unbounded</td></tr><tr><td><code>:Infeasible</code></td><td>Problem is infeasible</td></tr><tr><td><code>:UserLimit</code></td><td>Iteration limit or timeout</td></tr><tr><td><code>:Error</code></td><td>Solver exited with an error</td></tr><tr><td><code>:NotSolved</code></td><td>Model built in memory but not optimized</td></tr></table><h2><a class="nav-anchor" id="Quadratic-Objectives-1" href="#Quadratic-Objectives-1">Quadratic Objectives</a></h2><p>Quadratic objectives are supported by JuMP using a solver which implements the corresponding extensions of the MathProgBase interface. Add them in the same way you would a linear objective:</p><pre><code class="language-none">using Ipopt
m = Model(solver=IpoptSolver())
@variable(m, 0 &lt;= x &lt;= 2 )
@variable(m, 0 &lt;= y &lt;= 30 )

@objective(m, Min, x*x+ 2x*y + y*y )
@constraint(m, x + y &gt;= 1 )

print(m)

status = solve(m)</code></pre><h2><a class="nav-anchor" id="Second-order-cone-constraints-1" href="#Second-order-cone-constraints-1">Second-order cone constraints</a></h2><p>Second-order cone constraints of the form <span>$||Ax − b||_2 + a^Tx + c \leq 0$</span> can be added directly using the <code>norm</code> function:</p><pre><code class="language-none">@constraint(m, norm(A*x) &lt;= 2w - 1)</code></pre><p>You may use generator expressions within <code>norm()</code> to build up normed expressions with complex indexing operations in much the same way as with <code>sum(...)</code>:</p><pre><code class="language-none">@constraint(m, norm(2x[i] - i for i=1:n if c[i] == 1) &lt;= 1)</code></pre><h2><a class="nav-anchor" id="Accessing-the-low-level-model-1" href="#Accessing-the-low-level-model-1">Accessing the low-level model</a></h2><p>It is possible to construct the internal low-level model before optimizing. To do this, call the <code>JuMP.build</code> function. It is then possible to obtain this model by using the <code>internalmodel</code> function. This may be useful when it is necessary to access some functionality that is not exposed by JuMP. When you are ready to optimize, simply call <code>solve</code> in the normal fashion.</p><footer><hr/><a class="previous" href="quickstart.html"><span class="direction">Previous</span><span class="title">Quick Start Guide</span></a><a class="next" href="refvariable.html"><span class="direction">Next</span><span class="title">Variables</span></a></footer></article></body></html>
