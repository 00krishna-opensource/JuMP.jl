<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Solver Callbacks · JuMP</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-44252521-1', 'auto');
ga('send', 'pageview');
</script><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/highlightjs/default.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>JuMP</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Introduction</a></li><li><a class="toctext" href="installation.html">Installation Guide</a></li><li><a class="toctext" href="quickstart.html">Quick Start Guide</a></li><li><a class="toctext" href="refmodel.html">Models</a></li><li><a class="toctext" href="refvariable.html">Variables</a></li><li><a class="toctext" href="refexpr.html">Expressions and Constraints</a></li><li><a class="toctext" href="probmod.html">Problem Modification</a></li><li class="current"><a class="toctext" href="callbacks.html">Solver Callbacks</a><ul class="internal"><li><a class="toctext" href="#Lazy-Constraints-1">Lazy Constraints</a></li><li><a class="toctext" href="#User-Cuts-1">User Cuts</a></li><li><a class="toctext" href="#User-Heuristics-1">User Heuristics</a></li><li><a class="toctext" href="#Querying-Solver-Progress-1">Querying Solver Progress</a></li><li><a class="toctext" href="#Informational-Callbacks-1">Informational Callbacks</a></li><li><a class="toctext" href="#Code-Design-Considerations-1">Code Design Considerations</a></li><li><a class="toctext" href="#Exiting-a-callback-early-1">Exiting a callback early</a></li></ul></li><li><a class="toctext" href="nlp.html">Nonlinear Modeling</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="callbacks.html">Solver Callbacks</a></li></ul><a class="edit-page" href="https://github.com/JuliaOpt/JuMP.jl/tree/8ea959a5cb9bb95b554b5636b1d2e21ad25c5c2b/docs/src/callbacks.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Solver Callbacks</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Solver-Callbacks-1" href="#Solver-Callbacks-1">Solver Callbacks</a></h1><p>Many mixed-integer (linear, conic, and nonlinear) programming solvers offer the ability to modify the solve process. Examples include changing branching decisions in branch-and-bound, adding custom cutting planes, providing custom heuristics to find feasible solutions, or implementing on-demand separators to add new constraints only when they are violated by the current solution (also known as lazy constraints).</p><p>While historically this functionality has been limited to solver-specific interfaces, JuMP provides <em>solver-independent</em> support for a number of commonly used solver callbacks. Currently, we support lazy constraints, user-provided cuts, and user-provided heuristics for the Gurobi, CPLEX, GLPK, and SCIP solvers. We do not yet support any other class of callbacks, but they may be accessible by using the solver&#39;s low-level interface.</p><h2><a class="nav-anchor" id="Lazy-Constraints-1" href="#Lazy-Constraints-1">Lazy Constraints</a></h2><p>Lazy constraints are useful when the full set of constraints is too large to explicitly include in the initial formulation. When a MIP solver reaches a new solution, for example with a heuristic or by solving a problem at a node in the branch-and-bound tree, it will give the user the chance to provide constraint(s) that would make the current solution infeasible. For some more information about lazy constraints, see this blog post by <a href="http://orinanobworld.blogspot.com/2012/08/user-cuts-versus-lazy-constraints.html">Paul Rubin</a>.</p><p>There are three important steps to providing a lazy constraint callback. First we must write a function that will analyze the current solution that takes a single argument, e.g. <code>function myLazyConGenerator(cb)</code>, where cb is a reference to the callback management code inside JuMP. Next you will do whatever analysis of the solution you need to inside your function to generate the new constraint before adding it to the model with <code>@lazyconstraint(cb, myconstraint)</code>. There is an optional keyword option <code>localcut</code> to <code>@lazyconstraint</code>, which indicates if the lazy constraint that will be added will only apply at the current node and the tree rooted at that node. For example, <code>@lazyconstraint(cb, myconstraint, localcut=true)</code>. By default, <code>localcut</code> is set to <code>false</code>. Finally we notify JuMP that this function should be used for lazy constraint generation using the <code>addlazycallback(m, myLazyConGenerator)</code> function before we call <code>solve(m)</code>.</p><p>The following is a simple example to make this more clear. In this two-dimensional problem we have a set of box constraints explicitly provided and a set of two lazy constraints we can add on the fly. The solution without the lazy constraints will be either (0,2) or (2,2), and the final solution will be (1,2):</p><pre><code class="language-julia">using JuMP
using Gurobi

# We will use Gurobi
m = Model(solver=GurobiSolver())

# Define our variables to be inside a box, and integer
@variable(m, 0 &lt;= x &lt;= 2, Int)
@variable(m, 0 &lt;= y &lt;= 2, Int)

@objective(m, Max, y)

# We now define our callback function that takes one argument,
# the callback handle. Note that we can access m, x, and y because
# this function is defined inside the same scope
function corners(cb)
    x_val = getvalue(x)
    y_val = getvalue(y)
    println(&quot;In callback function, x=$x_val, y=$y_val&quot;)

    # We have two constraints, one cutting off the top
    # left corner and one cutting off the top right corner, e.g.
    # (0,2) +---+---+ (2,2)
    #       |xx/ \xx|
    #       |x/   \x|
    #       |/     \|
    #       +       +
    #       |       |
    #       |       |
    #       |       |
    # (0,0) +---+---+ (2,0)

    # Allow for some impreciseness in the solution
    TOL = 1e-6

    # Check top left, allowing some tolerance
    if y_val - x_val &gt; 1 + TOL
        # Cut off this solution
        println(&quot;Solution was in top left, cut it off&quot;)
        # Use the original variables, but not m - cb instead
        @lazyconstraint(cb, y - x &lt;= 1)
    # Check top right
    elseif y_val + x_val &gt; 3 + TOL
        # Cut off this solution
        println(&quot;Solution was in top right, cut it off&quot;)
        # Use the original variables, but not m - cb instead
        @lazyconstraint(cb, y + x &lt;= 3)
    end
end  # End of callback function

# Tell JuMP/Gurobi to use our callback function
addlazycallback(m, corners)

# Solve the problem
solve(m)

# Print our final solution
println(&quot;Final solution: [ $(getvalue(x)), $(getvalue(y)) ]&quot;)</code></pre><p>The code should print something like (amongst the output from Gurobi):</p><pre><code class="language-none">In callback function, x=2.0, y=2.0
Solution was in top right, cut it off
In callback function, x=0.0, y=2.0
Solution was in top left, cut it off
In callback function, x=1.0, y=2.0
Final solution: [ 1.0, 2.0 ]</code></pre><p>This code can also be found in <code>/JuMP/examples/simplelazy.jl</code>.</p><p>There is an optional <code>fractional</code> keyword option to <code>addlazycallback</code> which indicates that the callback may be called at solutions that do not satisfy integrality constraints. For example, <code>addlazycallback(m, myLazyConGenerator, fractional=true)</code>. Depending on the solver, this may invoke the callback after solving each LP relaxation in the Branch and Bound tree. By default, <code>fractional</code> is set to <code>false</code>.</p><h2><a class="nav-anchor" id="User-Cuts-1" href="#User-Cuts-1">User Cuts</a></h2><p>User cuts, or simply cuts, provide a way for the user to tighten the LP relaxation using problem-specific knowledge that the solver cannot or is unable to infer from the model. Just like with lazy constraints, when a MIP solver reaches a new node in the branch-and-bound tree, it will give the user the chance to provide cuts to make the current relaxed (fractional) solution infeasible in the hopes of obtaining an integer solution. For more details about the difference between user cuts and lazy constraints see the aforementioned <a href="http://orinanobworld.blogspot.com/2012/08/user-cuts-versus-lazy-constraints.html">blog post</a>.</p><p>Your user cuts should not change the set of integer feasible solutions. Equivalently, your cuts can only remove fractional solutions - that is, &quot;tighten&quot; the LP relaxation of the MILP. If you add a cut that removes an integer solution, the solver may return an incorrect solution.</p><p>Adding a user cut callback is similar to adding a lazy constraint callback. First we must write a function that will analyze the current solution that takes a single argument, e.g. <code>function myUserCutGenerator(cb)</code>, where cb is a reference to the callback management code inside JuMP. Next you will do whatever analysis of the solution you need to inside your function to generate the new constraint before adding it to the model with the JuMP macro <code>@usercut(cb, myconstraint)</code> (same limitations as addConstraint). There is an optional keyword option <code>localcut</code> to <code>@usercut</code>, which indicates if the user cut that will be added will only apply at the current node and the tree rooted at that node. For example, <code>@usercut(cb, myconstraint, localcut=true)</code>. By default, <code>localcut</code> is set to <code>false</code>. Finally we notify JuMP that this function should be used for user cut generation using the <code>addcutcallback(m, myUserCutGenerator)</code> function before we call <code>solve(m)</code>.</p><p>Consider the following example which is related to the lazy constraint example. The problem is two-dimensional, and the objective sense prefers solution in the top-right of a 2-by-2 square. There is a single constraint that cuts off the top-right corner to make the LP relaxation solution fractional. We will exploit our knowledge of the problem structure to add a user cut that will make the LP relaxation integer, and thus solve the problem at the root node:</p><pre><code class="language-julia">using JuMP
using Gurobi

# We will use Gurobi, which requires that we manually set the attribute
# PreCrush to 1 if we have user cuts. We will also disable PreSolve, Cuts,
# and Heuristics so only our cut will be used
m = Model(solver=GurobiSolver(PreCrush=1, Cuts=0, Presolve=0, Heuristics=0.0))

# Define our variables to be inside a box, and integer
@variable(m, 0 &lt;= x &lt;= 2, Int)
@variable(m, 0 &lt;= y &lt;= 2, Int)

# Optimal solution is trying to go towards top-right corner (2.0, 2.0)
@objective(m, Max, x + 2y)

# We have one constraint that cuts off the top right corner
@constraint(m, y + x &lt;= 3.5)

# Optimal solution of relaxed problem will be (1.5, 2.0)
# We can add a user cut that will cut of this fractional solution.

# We now define our callback function that takes one argument,
# the callback handle. Note that we can access m, x, and y because
# this function is defined inside the same scope
function mycutgenerator(cb)
    x_val = getvalue(x)
    y_val = getvalue(y)
    println(&quot;In callback function, x=$x_val, y=$y_val&quot;)

    # Allow for some impreciseness in the solution
    TOL = 1e-6

    # Check top right
    if y_val + x_val &gt; 3 + TOL
        # Cut off this solution
        println(&quot;Fractional solution was in top right, cut it off&quot;)
        # Use the original variables
        @usercut(cb, y + x &lt;= 3)
    end
end  # End of callback function

# Tell JuMP/Gurobi to use our callback function
addcutcallback(m, mycutgenerator)

# Solve the problem
solve(m)

# Print our final solution
println(&quot;Final solution: [ $(getvalue(x)), $(getvalue(y)) ]&quot;)</code></pre><p>The code should print something like (amongst the output from Gurobi):</p><pre><code class="language-none">In callback function, x=1.5, y=2.0
Fractional solution was in top right, cut it off
In callback function, x=1.0, y=2.0
Final solution: [ 1.0, 2.0 ]</code></pre><p>This code can also be found in <code>/JuMP/examples/simpleusercut.jl</code>.</p><h2><a class="nav-anchor" id="User-Heuristics-1" href="#User-Heuristics-1">User Heuristics</a></h2><p>Integer programming solvers frequently include heuristics that run at the nodes of the branch-and-bound tree. They aim to find integer solutions quicker than plain branch-and-bound would to tighten the bound, allowing us to fathom nodes quicker and to tighten the integrality gap. Some heuristics take integer solutions and explore their &quot;local neighborhood&quot; (e.g. flipping binary variables, fix some variables and solve a smaller MILP, ...) and others take fractional solutions and attempt to round them in an intelligent way. You may want to add a heuristic of your own if you have some special insight into the problem structure that the solver is not aware of, e.g. you can consistently take fractional solutions and intelligently guess integer solutions from them.</p><p>The user heuristic callback is somewhat different from the previous two heuristics. The general concept is that we can create multiple partial solutions and submit them back to the solver - each solution must be submitted before a new solution is constructed. As before we provide a function that analyzes the current solution and takes a single argument, e.g. <code>function myHeuristic(cb)</code>, where cb is a reference to the callback management code inside JuMP. You can build your solutions using <code>setsolutionvalue(cb, x, value)</code> and submit them with <code>addsolution(cb)</code>. Note that <code>addsolution</code> will &quot;wipe&quot; the previous (partial) solution. Notify JuMP that this function should be used as a heuristic using the <code>addheuristiccallback(m, myHeuristic)</code> function before calling <code>solve(m)</code>.</p><p>There is some unavoidable (for performance reasons) solver-dependent behavior - you should check your solver documentation for details. For example: GLPK will not check the feasibility of your heuristic solution. If you need to submit many heuristic solutions in one callback, there may be performance impacts from the &quot;wiping&quot; behavior of <code>addsolution</code> - please file an issue and we can address this issue.</p><p>Consider the following example, which is the same problem as seen in the user cuts section. The heuristic simply rounds the fractional variable to generate integer solutions.:</p><pre><code class="language-julia">using JuMP
using Gurobi

# We will use Gurobi and disable PreSolve, Cuts, and (in-built) Heuristics so
# only our heuristic will be used
m = Model(solver=GurobiSolver(Cuts=0, Presolve=0, Heuristics=0.0))

# Define our variables to be inside a box, and integer
@variable(m, 0 &lt;= x &lt;= 2, Int)
@variable(m, 0 &lt;= y &lt;= 2, Int)

# Optimal solution is trying to go towards top-right corner (2.0, 2.0)
@objective(m, Max, x + 2y)

# We have one constraint that cuts off the top right corner
@constraint(m, y + x &lt;= 3.5)

# Optimal solution of relaxed problem will be (1.5, 2.0)

# We now define our callback function that takes one argument,
# the callback handle. Note that we can access m, x, and y because
# this function is defined inside the same scope
function myheuristic(cb)
    x_val = getvalue(x)
    y_val = getvalue(y)
    println(&quot;In callback function, x=$x_val, y=$y_val&quot;)

    setsolutionvalue(cb, x, floor(x_val))
    # Leave y undefined - solver should handle as it sees fit. In the case
    # of Gurobi it will try to figure out what it should be.
    addsolution(cb)

    # Submit a second solution
    setsolutionvalue(cb, x, ceil(x_val))
    addsolution(cb)
end  # End of callback function

# Tell JuMP/Gurobi to use our callback function
addheuristiccallback(m, myheuristic)

# Solve the problem
solve(m)

# Print our final solution
println(&quot;Final solution: [ $(getvalue(x)), $(getvalue(y)) ]&quot;)</code></pre><p>The code should print something like:</p><pre><code class="language-none">In callback function, x=1.5, y=2.0
     0     0    5.50000    0    1          -    5.50000     -      -    0s
H    1     0                       5.0000000    5.50000  10.0%   0.0    0s</code></pre><p>where the <code>H</code> denotes a solution found with a heuristic - our heuristic in this case. This code can also be found in <code>/JuMP/examples/simpleheur.jl</code>.</p><h2><a class="nav-anchor" id="Querying-Solver-Progress-1" href="#Querying-Solver-Progress-1">Querying Solver Progress</a></h2><p>All JuMP callback methods must take a single argument, called <code>cb</code> by convention. <code>cb</code> is a handle to the internal callback system used by the underlying solver, and allows the user to query solver state. There are a variety of methods available which are listed in the <a href="http://mathprogbasejl.readthedocs.org/en/latest/lpqcqp.html#mip-callbacks">MathProgBase documentation</a> including:</p><pre><code class="language-julia">cbgetobj(cb)
cbgetbestbound(cb)
cbgetexplorednodes(cb)
cbgetstate(cb)</code></pre><h2><a class="nav-anchor" id="Informational-Callbacks-1" href="#Informational-Callbacks-1">Informational Callbacks</a></h2><p>Sometimes it can be useful to track solver progress without actually changing the algorithm by adding cuts or heuristic solutions. In these cases, informational callbacks can be added, wherein statistics can be tracked via the <code>cbget</code> functions discussed in the previous section. Informational callbacks are added to a JuMP model with the <code>addinfocallback(m::Model, f::Function; when::Symbol)</code> function, where the when argument should be one of <code>:MIPNode</code>, <code>:MIPSol</code> or <code>:Intermediate</code> (listed under <code>cbgetstate()</code> in the <a href="https://mathprogbasejl.readthedocs.io/en/latest/lpqcqp.html#cbgetstate">MathProgBase documentation</a>)</p><p>For a simple example, we can add a function that tracks the best bound and incumbent objective value as the solver progresses through the branch-and-bound tree:</p><pre><code class="language-julia">type NodeData
    time::Float64  # in seconds since the epoch
    node::Int
    obj::Float64
    bestbound::Float64
end

# build model ``m`` up here

bbdata = NodeData[]

function infocallback(cb)
    node      = MathProgBase.cbgetexplorednodes(cb)
    obj       = MathProgBase.cbgetobj(cb)
    bestbound = MathProgBase.cbgetbestbound(cb)
    push!(bbdata, NodeData(time(),node,obj,bestbound))
end
addinfocallback(m, infocallback, when = :Intermediate)

solve(m)

# Save results to file for analysis later
open(&quot;bbtrack.csv&quot;,&quot;w&quot;) do fp
    println(fp, &quot;time,node,obj,bestbound&quot;)
    for bb in bbdata
        println(fp, bb.time, &quot;,&quot;, bb.node, &quot;,&quot;,
                    bb.obj, &quot;,&quot;, bb.bestbound)
    end
end</code></pre><p>For a second example, we can add a function that tracks the intermediate solutions at each integer-feasible solution in the Branch-and-Bound tree:</p><pre><code class="language-julia">solutionvalues = Vector{Float64}[]

# build model ``m`` up here

function infocallback(cb)
    push!(solutionvalues, JuMP.getvalue(x))
end
addinfocallback(m, infocallback, when = :MIPSol)

solve(m)

# all the intermediate solutions are now stored in `solutionvalues`</code></pre><h2><a class="nav-anchor" id="Code-Design-Considerations-1" href="#Code-Design-Considerations-1">Code Design Considerations</a></h2><p>In the above examples the callback function is defined in the same scope as the model and variable definitions, allowing us to access them. If we defined the function in some other scope, or even file, we would not be able to access them directly. The proposed solution to this design problem is to separate the logic of analyzing the current solution values from the callback itself. This has many benefits, including writing unit tests for the callback function to check its correctness. The callback function passed to JuMP is then simply a stub that extracts the current solution and any other relevant information and passes that to the constraint generation logic. To apply this to our previous lazy constraint example, consider the following code:</p><pre><code class="language-julia">using JuMP
using Gurobi
using Base.Test

function cornerChecker(x_val, y_val)
    # This function does not depend on the model, and could
    # be written anywhere. Instead, it returns a tuple of
    # values (newcut, x_coeff, y_coeff, rhs) where newcut is a
    # boolean if a cut is needed, x_coeff is the coefficient
    # on the x variable, y_coeff is the coefficient on
    # the y variable, and rhs is the right hand side
    TOL = 1e-6
    if y_val - x_val &gt; 1 + TOL
        return (true, -1.0, 1.0, 1.0)  # Top left
    elseif y_val + x_val &gt; 3 + TOL
        return (true,  1.0, 1.0, 3.0)  # Top right
    else
        return (false, 0.0, 0.0, 0.0)  # No cut
    end
end

# A unit test for the cornerChecker function
function test_cornerChecker()
    # Test the four corners - only two should produce cuts

    newcut, x_coeff, y_coeff, rhs = cornerChecker(0, 0)
    @test !newcut

    newcut, x_coeff, y_coeff, rhs = cornerChecker(2, 0)
    @test !newcut

    newcut, x_coeff, y_coeff, rhs = cornerChecker(0, 2)
    @test newcut
    @test x_coeff == -1.0
    @test y_coeff ==  1.0
    @test rhs == 1.0

    newcut, x_coeff, y_coeff, rhs = cornerChecker(2, 2)
    @test newcut
    @test x_coeff ==  1.0
    @test y_coeff ==  1.0
    @test rhs == 3.0
end

function solveProblem()
    m = Model(solver=GurobiSolver())

    @variable(m, 0 &lt;= x &lt;= 2, Int)
    @variable(m, 0 &lt;= y &lt;= 2, Int)
    @objective(m, Max, y)

    # Note that the callback is now a stub that passes off
    # the work to the &quot;algorithm&quot;
    function corners(cb)
        x_val = getvalue(x)
        y_val = getvalue(y)
        println(&quot;In callback function, x=$x_val, y=$y_val&quot;)

        newcut, x_coeff, y_coeff, rhs = cornerChecker(x_val, y_val)

        if newcut
            @lazyconstraint(cb, x_coeff*x + y_coeff*y &lt;= rhs)
        end
    end  # End of callback function

    addlazycallback(m, corners)
    solve(m)
    println(&quot;Final solution: [ $(getvalue(x)), $(getvalue(y)) ]&quot;)
end

# Run tests
test_cornerChecker()

# Solve it
solveProblem()</code></pre><p>This code can also be found in <code>/JuMP/examples/simplelazy2.jl</code>.</p><h2><a class="nav-anchor" id="Exiting-a-callback-early-1" href="#Exiting-a-callback-early-1">Exiting a callback early</a></h2><p>If you need to exit the optimization process earlier than a solver otherwise would, it is possible to return <code>JuMP.StopTheSolver</code> from the callback code:</p><pre><code class="language-julia">return JuMP.StopTheSolver</code></pre><p>This will trigger the solver to exit immediately and return a <code>:UserLimit</code> status.</p><footer><hr/><a class="previous" href="probmod.html"><span class="direction">Previous</span><span class="title">Problem Modification</span></a><a class="next" href="nlp.html"><span class="direction">Next</span><span class="title">Nonlinear Modeling</span></a></footer></article></body></html>
