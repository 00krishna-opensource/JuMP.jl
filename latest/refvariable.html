<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Variables · JuMP</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-44252521-1', 'auto');
ga('send', 'pageview');
</script><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/highlightjs/default.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>JuMP</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Introduction</a></li><li><a class="toctext" href="installation.html">Installation Guide</a></li><li><a class="toctext" href="quickstart.html">Quick Start Guide</a></li><li><a class="toctext" href="refmodel.html">Models</a></li><li class="current"><a class="toctext" href="refvariable.html">Variables</a><ul class="internal"><li><a class="toctext" href="#Constructors-1">Constructors</a></li><li><a class="toctext" href="#Anonymous-variables-1">Anonymous variables</a></li><li><a class="toctext" href="#Semidefinite-and-symmetric-variables-1">Semidefinite and symmetric variables</a></li><li><a class="toctext" href="#@variables-blocks-1"><code>@variables</code> blocks</a></li><li><a class="toctext" href="#Methods-1">Methods</a></li><li><a class="toctext" href="#Helper-functions-1">Helper functions</a></li><li><a class="toctext" href="#Fixed-variables-1">Fixed variables</a></li></ul></li><li><a class="toctext" href="refexpr.html">Expressions and Constraints</a></li><li><a class="toctext" href="probmod.html">Problem Modification</a></li><li><a class="toctext" href="callbacks.html">Solver Callbacks</a></li><li><a class="toctext" href="nlp.html">Nonlinear Modeling</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="refvariable.html">Variables</a></li></ul><a class="edit-page" href="https://github.com/JuliaOpt/JuMP.jl/tree/25a1021787fb8d29f05a2d161274b4ba557919e1/docs/src/refvariable.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Variables</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Variables-1" href="#Variables-1">Variables</a></h1><p>Variables, also known as columns or decision variables, are the results of the optimization.</p><h2><a class="nav-anchor" id="Constructors-1" href="#Constructors-1">Constructors</a></h2><p>The primary way to create variables is with the <code>@variable</code> macro. The first argument will always be a <code>Model</code>. In the examples below we assume <code>m</code> is already defined. The second argument is an expression that declares the variable name and optionally allows specification of lower and upper bounds. Adding variables &quot;column-wise&quot;, e.g., as in column generation, is supported as well; see the syntax discussed in the <a href="probmod.html#Problem-Modification-1">Problem Modification</a> section.</p><pre><code class="language-julia">@variable(m, x )              # No bounds
@variable(m, x &gt;= lb )        # Lower bound only (note: &#39;lb &lt;= x&#39; is not valid)
@variable(m, x &lt;= ub )        # Upper bound only
@variable(m, lb &lt;= x &lt;= ub )  # Lower and upper bounds
@variable(m, x == fixedval )  # Fixed to a value (lb == ub)</code></pre><p>All these variations create a new local variable, in this case <code>x</code>. The names of your variables must be valid Julia variable names. Integer and binary restrictions can optionally be specified with a third argument, <code>Int</code> or <code>Bin</code>. For advanced users, <code>SemiCont</code> and <code>SemiInt</code> may be used to create <a href="http://orinanobworld.blogspot.com/2011/03/semicontinuous-variables.html">semicontinuous</a> or <a href="http://www.gams.com/help/topic/gams.doc/userguides/mccarl/semi-integer_variables.htm">semi-integer</a> variables, respectively.</p><p>To create arrays of variables we append brackets to the variable name.</p><pre><code class="language-julia">@variable(m, x[1:M,1:N] &gt;= 0 )</code></pre><p>will create an <code>M</code> by <code>N</code> array of variables. Both ranges and arbitrary iterable sets are supported as index sets. Currently we only support ranges of the form <code>a:b</code> where <code>a</code> is an explicit integer, not a variable. Using ranges will generally be faster than using arbitrary symbols. You can mix both ranges and lists of symbols, as in the following example:</p><pre><code class="language-julia">s = [&quot;Green&quot;,&quot;Blue&quot;]
@variable(m, x[-10:10,s] , Int)
x[-4,&quot;Green&quot;]</code></pre><p>Bounds can depend on variable indices:</p><pre><code class="language-julia">@variable(m, x[i=1:10] &gt;= i )</code></pre><p>And indices can have dependencies on preceding indices (e.g. &quot;triangular indexing&quot;):</p><pre><code class="language-julia">@variable(m, x[i=1:10,j=i:10] &gt;= 0)</code></pre><p>Note the dependency must be on preceding indices, going from left to right. That is, <code>@variable(m, x[i=j:10,i=1:10] &gt;= 0)</code> is not valid JuMP code.</p><p>Conditions can be placed on the index values for which variables are created; the condition follows the statement of the index sets and is separated with a semicolon:</p><pre><code class="language-julia">@variable(m, x[i=1:10,j=1:10; isodd(i+j)] &gt;= 0)</code></pre><p>Note that only one condition can be added, although expressions can be built up by using the usual <code>&amp;&amp;</code> and <code>||</code> logical operators.</p><p>An initial value of each variable may be provided with the <code>start</code> keyword to <code>@variable</code>:</p><pre><code class="language-julia">@variable(m, x[i=1:10], start=(i/2))</code></pre><p>Is equivalent to:</p><pre><code class="language-julia">@variable(m, x[i=1:10])
for i in 1:10
    setvalue(x[i], i/2)
end</code></pre><p>For more complicated variable bounds, it may be clearer to specify them using the <code>lowerbound</code> and <code>upperbound</code> keyword arguments to <code>@variable</code>:</p><pre><code class="language-julia">@variable(m, x[i=1:3], lowerbound=my_complex_function(i))
@variable(m, x[i=1:3], lowerbound=my_complex_function(i), upperbound=another_function(i))</code></pre><p>Variable categories may be set in a more programmatic way by providing the appropriate symbol to the <code>category</code> keyword argument:</p><pre><code class="language-julia">t = [:Bin,:Int]
@variable(m, x[i=1:2], category=t[i])
@variable(m, y, category=:SemiCont)</code></pre><p>The constructor <code>Variable(m::Model,idx::Int)</code> may be used to create a variable object corresponding to an <em>existing</em> variable in the model (the constructor does not add a new variable to the model). The variable indices correspond to those of the internal MathProgBase model. The inverse of this operation is <code>linearindex(x::Variable)</code>, which returns the flattened out (linear) index of a variable as JuMP provides it to a solver. We guarantee that <code>Variable(m,linearindex(x))</code> returns <code>x</code> itself. These methods are only useful if you intend to interact with solver properties which are not directly exposed through JuMP.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p><code>@variable</code> is equivalent to a simple assignment <code>x = ...</code> in Julia and therefore redefines variables. The following code will generate a warning and may lead to unexpected results:</p><pre><code class="language-julia">@variable(m, x[1:10,1:10])
@variable(m, x[1:5])</code></pre><p>After the second line, the Julia variable <code>x</code> refers to a set of variables indexed by the range <code>1:5</code>. The reference to the first set of variables has been lost, although they will remain in the model. See also the section on anonymous variables.</p></div></div><h2><a class="nav-anchor" id="Anonymous-variables-1" href="#Anonymous-variables-1">Anonymous variables</a></h2><p>We also provide a syntax for constructing &quot;anonymous&quot; variables. In <code>@variable</code>, you may omit the name of the variable and instead assign the return value as you would like:</p><pre><code class="language-julia">x = @variable(m) # Equivalent to @variable(m, x)
x = @variable(m, [i=1:3], lowerbound = i, upperbound = 2i) # Equivalent to @variable(m, i &lt;= x[i=1:3] &lt;= 2i)</code></pre><p>The <code>lowerbound</code> and <code>upperbound</code> keywords must be used instead of comparison operators for specifying variable bounds within the anonymous syntax. For creating noncontinuous anonymous variables, the <code>category</code> keyword must be used to avoid ambiguity, e.g.:</p><pre><code class="language-julia">x = @variable(m, Bin) # error
x = @variable(m, category = :Bin) # ok</code></pre><p>Besides these syntax restrictions in the <code>@variable</code> macro, the <strong>only</strong> differences between anonymous and named variables are:</p><blockquote><ol><li><p>For the purposes of printing a model, JuMP will not have a name for anonymous variables and will instead use <code>__anon__</code>. You may set the name of a variable for printing by using <code>setname</code> or the <code>basename</code> keyword argument described below.</p></li><li><p>Anonymous variables cannot be retrieved by using <code>getindex</code> or <code>m[name]</code>.</p></li></ol></blockquote><p>If you would like to change the name used when printing a variable or group of variables, you may use the <code>basename</code> keyword argument:</p><pre><code class="language-julia">i = 3
@variable(m, x[1:3], basename=&quot;myvariable-$i&quot;)
# OR:
x = @variable(m, [1:3], basename=&quot;myvariable-$i&quot;)</code></pre><p>Printing <code>x[2]</code> will display <code>myvariable-3[2]</code>.</p><h2><a class="nav-anchor" id="Semidefinite-and-symmetric-variables-1" href="#Semidefinite-and-symmetric-variables-1">Semidefinite and symmetric variables</a></h2><p>JuMP supports modeling with <a href="https://en.wikipedia.org/wiki/Semidefinite_programming">semidefinite variables</a>. A square symmetric matrix <span>$X$</span> is positive semidefinite if all eigenvalues are nonnegative; this is typically denoted by <span>$X \succeq 0$</span>. You can declare a matrix of variables to be positive semidefinite as follows:</p><pre><code class="language-julia">@variable(m, X[1:3,1:3], SDP)</code></pre><p>Note in particular the indexing: 1) exactly two index sets must be specified, 2) they must both be unit ranges starting at 1, 3) no bounds can be provided alongside the <code>SDP</code> tag. If you wish to impose more complex semidefinite constraints on the variables, e.g. <span>$X − I \succeq 0$</span>, you may instead use the <code>Symmetric</code> tag, along with a semidefinite constraint:</p><pre><code class="language-julia">@variable(m, X[1:n,1:n], Symmetric)
@SDconstraint(m, X &gt;= eye(n))</code></pre><p>Bounds can be provided as normal when using the <code>Symmetric</code> tag, with the stipulation that the bounds are symmetric themselves.</p><h2><a class="nav-anchor" id="@variables-blocks-1" href="#@variables-blocks-1"><code>@variables</code> blocks</a></h2><p>JuMP provides a convenient syntax for defining multiple variables in a single block:</p><pre><code class="language-julia">@variables m begin
    x
    y &gt;= 0
    Z[1:10], Bin
    X[1:3,1:3], SDP
    q[i=1:2], (lowerbound = i, start = 2i, upperbound = 3i)
    t[j=1:3], (Int, start = j)
end

# Equivalent to:
@variable(m, x)
@variable(m, y &gt;= 0)
@variable(m, Z[1:10], Bin)
@variable(m, X[1:3,1:3], SDP)
@variable(m, q[i=1:2], lowerbound = i, start = 2i, upperbound = 3i)
@variable(m, t[j=1:3], Int, start = j)</code></pre><p>The syntax follows that of <code>@variable</code> with each declaration separated by a new line. Note that unlike in <code>@variable</code>, keyword arguments must be specified within parentheses.</p><h2><a class="nav-anchor" id="Methods-1" href="#Methods-1">Methods</a></h2><p><strong>Bounds</strong></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.setlowerbound" href="#JuMP.setlowerbound"><code>JuMP.setlowerbound</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">setlowerbound(v::Variable,lower::Number)</code></pre><p>set the lower bound of a variable.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/JuMP.jl/tree/25a1021787fb8d29f05a2d161274b4ba557919e1/src/JuMP.jl#L539-L543">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.getlowerbound" href="#JuMP.getlowerbound"><code>JuMP.getlowerbound</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">getlowerbound(v::Variable)</code></pre><p>get the lower bound of a variable.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/JuMP.jl/tree/25a1021787fb8d29f05a2d161274b4ba557919e1/src/JuMP.jl#L559-L563">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.setupperbound" href="#JuMP.setupperbound"><code>JuMP.setupperbound</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">setupperbound(v::Variable,upper::Number)</code></pre><p>set the upper bound of a variable.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/JuMP.jl/tree/25a1021787fb8d29f05a2d161274b4ba557919e1/src/JuMP.jl#L549-L553">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.getupperbound" href="#JuMP.getupperbound"><code>JuMP.getupperbound</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">getupperbound(v::Variable)</code></pre><p>get the upper bound of a variable.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/JuMP.jl/tree/25a1021787fb8d29f05a2d161274b4ba557919e1/src/JuMP.jl#L566-L570">source</a><br/></section><p><strong>Variable Category</strong></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.setcategory" href="#JuMP.setcategory"><code>JuMP.setcategory</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">setcategory(v::Variable, cat::Symbol)</code></pre><p>Set the variable category for <code>v</code> after construction. Possible categories are <code>:Cont, :Int, :Bin, :SemiCont, :SemiInt</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/JuMP.jl/tree/25a1021787fb8d29f05a2d161274b4ba557919e1/src/JuMP.jl#L670-L674">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.getcategory" href="#JuMP.getcategory"><code>JuMP.getcategory</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">getcategory(v::Variable)</code></pre><p>Get the variable category for <code>v</code></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/JuMP.jl/tree/25a1021787fb8d29f05a2d161274b4ba557919e1/src/JuMP.jl#L680-L684">source</a><br/></section><p><strong>Values</strong></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.getvalue-Tuple{JuMP.Variable}" href="#JuMP.getvalue-Tuple{JuMP.Variable}"><code>JuMP.getvalue</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">getvalue(v::Variable)</code></pre><p>Get the value of this variable in the solution.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/JuMP.jl/tree/25a1021787fb8d29f05a2d161274b4ba557919e1/src/JuMP.jl#L598-L602">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.getvalue-Tuple{Array{JuMP.Variable,N} where N}" href="#JuMP.getvalue-Tuple{Array{JuMP.Variable,N} where N}"><code>JuMP.getvalue</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">getvalue(arr::Array{Variable})</code></pre><p>Returns an indexable dictionary of values. When the model is unbounded, returns the corresponding components of an unbounded ray, if available from the solver.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/JuMP.jl/tree/25a1021787fb8d29f05a2d161274b4ba557919e1/src/JuMP.jl#L611-L615">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.setvalue" href="#JuMP.setvalue"><code>JuMP.setvalue</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">setvalue(v::Variable, val::Number)</code></pre><p>Provide an initial value <code>v</code> for this variable that can be used by supporting MILP solvers. If <code>v</code> is <code>NaN</code>, the solver may attempt to fill in this value to construct a feasible solution. <code>setvalue</code> cannot be used with fixed variables; instead their value may be set with <code>JuMP.fix(x,v)</code></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/JuMP.jl/tree/25a1021787fb8d29f05a2d161274b4ba557919e1/src/JuMP.jl#L573-L577">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.getdual" href="#JuMP.getdual"><code>JuMP.getdual</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">getdual(v::Variable)</code></pre><p>Get the reduced cost of this variable in the solution. Similar behavior to <code>getvalue</code> for indexable variables.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/JuMP.jl/tree/25a1021787fb8d29f05a2d161274b4ba557919e1/src/JuMP.jl#L654-L658">source</a><br/><div><pre><code class="language-none">getdual(c::ConstraintRef{Model,SDConstraint})</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/JuMP.jl/tree/25a1021787fb8d29f05a2d161274b4ba557919e1/src/sd.jl#L87-L90">source</a><br/><div><pre><code class="language-none">getdual(c::LinConstrRef)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/JuMP.jl/tree/25a1021787fb8d29f05a2d161274b4ba557919e1/src/JuMP.jl#L763-L766">source</a><br/><div><pre><code class="language-none">getdual(c::ConstraintRef{Model,SOCConstraint})</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/JuMP.jl/tree/25a1021787fb8d29f05a2d161274b4ba557919e1/src/JuMP.jl#L842-L846">source</a><br/></section><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>The <code>getvalue</code> function always returns a floating-point value, even when a variable is constrained to take integer values, as most solvers only guarantee integrality up to a particular numerical tolerance. The built-in <code>round</code> function should be used to obtain integer values, e.g., by calling <code>round(Integer, getvalue(x))</code>.</p></div></div><p><strong>Names</strong></p><p>Variables (in the sense of columns) can have internal names (different from the Julia variable name) that can be used for writing models to file. This feature is disabled for performance reasons, but will be added if there is demand or a special use case.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.setname" href="#JuMP.setname"><code>JuMP.setname</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">setname(v::Variable,n::AbstractString)</code></pre><p>Set the variable&#39;s internal name.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/JuMP.jl/tree/25a1021787fb8d29f05a2d161274b4ba557919e1/src/JuMP.jl#L512-L516">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.getname" href="#JuMP.getname"><code>JuMP.getname</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">getname(m::Model, col)</code></pre><p>Get the variable&#39;s internal name.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/JuMP.jl/tree/25a1021787fb8d29f05a2d161274b4ba557919e1/src/JuMP.jl#L523-L527">source</a><br/><div><pre><code class="language-none">getname(v::Variable)</code></pre><p>Get the variable&#39;s internal name.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/JuMP.jl/tree/25a1021787fb8d29f05a2d161274b4ba557919e1/src/JuMP.jl#L530-L534">source</a><br/></section><h2><a class="nav-anchor" id="Helper-functions-1" href="#Helper-functions-1">Helper functions</a></h2><p>The following built-in functions are overloaded to provide easy construction of expressions from variables,</p><ul><li><p><code>sum(x)</code> - Operates on arrays of variables, efficiently produces an affine expression. Available in macros.</p></li><li><p><code>dot(x, coeffs)</code> - Performs a generalized &quot;dot product&quot; for arrays of variables and coefficients up to three dimensions, or equivalently the sum of the elements of the Hadamard product. Available in macros, and also as <code>dot(coeffs, x)</code>.</p></li></ul><h2><a class="nav-anchor" id="Fixed-variables-1" href="#Fixed-variables-1">Fixed variables</a></h2><p>Fixed variables, created with the <code>x == fixedval</code> syntax, have slightly special semantics. First, it is important to note that fixed variables are considered optimization variables, not constants, for the purpose of determining the problem class. For example, in:</p><pre><code class="language-julia">@variable(m, x == 5)
@variable(m, y)
@constraint(m, x*y &lt;= 10)</code></pre><p>the constraint added is a nonconvex quadratic constraint. For efficiency reasons, JuMP will <em>not</em> substitute the constant <code>5</code> for <code>x</code> and then provide the resulting <em>linear</em> constraint to the solver. Two possible uses for fixed variables are:</p><ol><li><p>For computing sensitivities. When available from the solver, the sensitivity of the objective with respect to the fixed value may be queried with <code>getdual(x)</code>.</p></li><li><p>For solving a sequence of problems with varying parameters. One may call <code>JuMP.fix(x, val)</code> to change the value of a fixed variable or to fix a previously unfixed variable. For LPs in particular, most solvers are able to efficiently hot-start when solving the resulting modified problem.</p></li></ol><footer><hr/><a class="previous" href="refmodel.html"><span class="direction">Previous</span><span class="title">Models</span></a><a class="next" href="refexpr.html"><span class="direction">Next</span><span class="title">Expressions and Constraints</span></a></footer></article></body></html>
