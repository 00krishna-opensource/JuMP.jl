<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Expressions and Constraints · JuMP</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-44252521-1', 'auto');
ga('send', 'pageview');
</script><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/highlightjs/default.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>JuMP</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Introduction</a></li><li><a class="toctext" href="installation.html">Installation Guide</a></li><li><a class="toctext" href="quickstart.html">Quick Start Guide</a></li><li><a class="toctext" href="refmodel.html">Models</a></li><li><a class="toctext" href="refvariable.html">Variables</a></li><li class="current"><a class="toctext" href="refexpr.html">Expressions and Constraints</a><ul class="internal"><li><a class="toctext" href="#Constructor-1">Constructor</a></li><li><a class="toctext" href="#Methods-1">Methods</a></li><li><a class="toctext" href="#Constraint-References-1">Constraint References</a></li><li><a class="toctext" href="#Conic-constraint-duals-1">Conic constraint duals</a></li><li><a class="toctext" href="#Vectorized-operations-1">Vectorized operations</a></li></ul></li><li><a class="toctext" href="probmod.html">Problem Modification</a></li><li><a class="toctext" href="callbacks.html">Solver Callbacks</a></li><li><a class="toctext" href="nlp.html">Nonlinear Modeling</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="refexpr.html">Expressions and Constraints</a></li></ul><a class="edit-page" href="https://github.com/JuliaOpt/JuMP.jl/tree/017ddcf6e1ec214dff3a6896d39c13a04b02d5be/docs/src/refexpr.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Expressions and Constraints</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Expressions-and-Constraints-1" href="#Expressions-and-Constraints-1">Expressions and Constraints</a></h1><h2><a class="nav-anchor" id="Constructor-1" href="#Constructor-1">Constructor</a></h2><p><code>AffExpr</code> is an affine expression type defined by JuMP. It has three fields: a vector of coefficients, a vector of variables, and a constant. Apart from a default constructor that takes no arguments, it also has a full constructor that can be useful if you want to manually build an affine expression:</p><pre><code class="language-julia">aff = AffExpr([x, z], [3.0, 4.0], 2.0)  # 3x + 4z + 2</code></pre><p>Note that the coefficients must be floating point numbers. The matching constraint for <code>AffExpr</code> is <code>LinearConstraint</code> which is defined by an <code>AffExpr</code> and a lower and upper bound. If a solver interface does not support range constraints, this will automatically translated into two constraints at solve time. Constructing constraints manually is not an expected behavior and won&#39;t add the constraint to a model automatically. See below for the correct methods.</p><p>There is also <code>QuadExpr</code> for quadratic expressions type that also provides a default constructor that takes no arguments and a full constructor. There are four fields: two vectors of variables, a vector of coefficients, and the affine part of the expression. This is best explained by example:</p><pre><code class="language-julia">aff = AffExpr([x, z], [3.0, 4.0], 2.0)  # 3x + 4z + 2
quad = QuadExpr([x,y],[x,z],[3.0,4.0],aff)  # 3x^2 + 4yz + 3x + 4z + 2</code></pre><p>The corresponding constraint is <code>QuadConstraint</code>, which is expected to be a convex quadratic constraint.</p><h2><a class="nav-anchor" id="Methods-1" href="#Methods-1">Methods</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.addconstraint" href="#JuMP.addconstraint"><code>JuMP.addconstraint</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">addconstraint(m::Model, c::LinearConstraint)</code></pre><p>Add a linear constraint to <code>Model m</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/JuMP.jl/tree/017ddcf6e1ec214dff3a6896d39c13a04b02d5be/src/affexpr.jl#L193-L197">source</a><br/><div><pre><code class="language-none">addconstraint(m::Model, c::QuadConstraint)</code></pre><p>Add a quadratic constraint to <code>Model m</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/JuMP.jl/tree/017ddcf6e1ec214dff3a6896d39c13a04b02d5be/src/quadexpr.jl#L125-L129">source</a><br/><div><pre><code class="language-none">addconstraint(m::Model, c::SOCConstraint)</code></pre><p>Add a SOC constraint to <code>Model m</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/JuMP.jl/tree/017ddcf6e1ec214dff3a6896d39c13a04b02d5be/src/norms.jl#L124-L128">source</a><br/><div><pre><code class="language-none">addconstraint(m::Model, c::SDConstraint)</code></pre><p>Add a SD constraint to <code>Model m</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/JuMP.jl/tree/017ddcf6e1ec214dff3a6896d39c13a04b02d5be/src/sd.jl#L19-L23">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.@constraint" href="#JuMP.@constraint"><code>JuMP.@constraint</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@constraint(m::Model, con)</code></pre><p>add linear or quadratic constraints.</p><pre><code class="language-none">@constraint(m::Model, ref, con)</code></pre><p>add groups of linear or quadratic constraints.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/JuMP.jl/tree/017ddcf6e1ec214dff3a6896d39c13a04b02d5be/src/macros.jl#L351-L360">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.@constraints" href="#JuMP.@constraints"><code>JuMP.@constraints</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@constraints(m, args...)</code></pre><p>adds groups of constraints at once, in the same fashion as @constraint. The model must be the first argument, and multiple constraints can be added on multiple lines wrapped in a <code>begin ... end</code> block. For example:</p><pre><code class="language-none">@constraints(m, begin
  x &gt;= 1
  y - w &lt;= 2
  sum_to_one[i=1:3], z[i] + y == 1
end)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/JuMP.jl/tree/017ddcf6e1ec214dff3a6896d39c13a04b02d5be/src/macros.jl#L735-L745">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.@expression" href="#JuMP.@expression"><code>JuMP.@expression</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@expression(args...)</code></pre><p>efficiently builds a linear, quadratic, or second-order cone expression but does not add to model immediately. Instead, returns the expression which can then be inserted in other constraints. For example:</p><pre><code class="language-julia">@expression(m, shared, sum(i*x[i] for i=1:5))
@constraint(m, shared + y &gt;= 5)
@constraint(m, shared + z &lt;= 10)</code></pre><p>The <code>ref</code> accepts index sets in the same way as <code>@variable</code>, and those indices can be used in the construction of the expressions:</p><pre><code class="language-julia">@expression(m, expr[i=1:3], i*sum(x[j] for j=1:3))</code></pre><p>Anonymous syntax is also supported:</p><pre><code class="language-julia">expr = @expression(m, [i=1:3], i*sum(x[j] for j=1:3))</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/JuMP.jl/tree/017ddcf6e1ec214dff3a6896d39c13a04b02d5be/src/macros.jl#L796-L818">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.@SDconstraint" href="#JuMP.@SDconstraint"><code>JuMP.@SDconstraint</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@SDconstraint(m, x)</code></pre><p>Adds a semidefinite constraint to the <code>Model m</code>. The expression <code>x</code> must be a square, two-dimensional array.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/JuMP.jl/tree/017ddcf6e1ec214dff3a6896d39c13a04b02d5be/src/macros.jl#L507-L511">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.addSOS1" href="#JuMP.addSOS1"><code>JuMP.addSOS1</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">addSOS1(m::Model, coll::Vector{AffExpr})</code></pre><p>Adds special ordered set constraint of type 1 (SOS1). Specify the set as a vector of weighted variables, e.g. <code>coll = [3x, y, 2z]</code>. Note that solvers expect the weights to be unique. See <a href="http://lpsolve.sourceforge.net/5.5/SOS.htm">here</a> for more details. If there is no inherent weighting in your model, an SOS constraint is probably unnecessary.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/JuMP.jl/tree/017ddcf6e1ec214dff3a6896d39c13a04b02d5be/src/sos.jl#L46-L50">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.addSOS2" href="#JuMP.addSOS2"><code>JuMP.addSOS2</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">addSOS2(m::Model, coll::Vector{AffExpr})</code></pre><p>Adds special ordered set constraint of type 2 (SOS2). Specify the set as a vector of weighted variables, e.g. <code>coll = [3x, y, 2z]</code>. Note that solvers expect the weights to be unique. See <a href="http://lpsolve.sourceforge.net/5.5/SOS.htm">here</a> for more details.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/JuMP.jl/tree/017ddcf6e1ec214dff3a6896d39c13a04b02d5be/src/sos.jl#L67-L71">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.@LinearConstraint" href="#JuMP.@LinearConstraint"><code>JuMP.@LinearConstraint</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@LinearConstraint(x)</code></pre><p>Constructs a <code>LinearConstraint</code> instance efficiently by parsing the <code>x</code>. The same as <code>@constraint</code>, except it does not attach the constraint to any model.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/JuMP.jl/tree/017ddcf6e1ec214dff3a6896d39c13a04b02d5be/src/macros.jl#L549-L553">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.@LinearConstraints" href="#JuMP.@LinearConstraints"><code>JuMP.@LinearConstraints</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@LinearConstraints(m, args...)</code></pre><p>Constructs a vector of <code>LinearConstraint</code> objects. Similar to <code>@LinearConstraint</code>, except it accepts multiple constraints as input as long as they are separated by newlines.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/JuMP.jl/tree/017ddcf6e1ec214dff3a6896d39c13a04b02d5be/src/macros.jl#L747-L751">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.@QuadConstraint" href="#JuMP.@QuadConstraint"><code>JuMP.@QuadConstraint</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@QuadConstraint(x)</code></pre><p>Constructs a <code>QuadConstraint</code> instance efficiently by parsing the <code>x</code>. The same as <code>@constraint</code>, except it does not attach the constraint to any model.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/JuMP.jl/tree/017ddcf6e1ec214dff3a6896d39c13a04b02d5be/src/macros.jl#L602-L606">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.@QuadConstraints" href="#JuMP.@QuadConstraints"><code>JuMP.@QuadConstraints</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@QuadConstraints(m, args...)</code></pre><p>Constructs a vector of <code>QuadConstraint</code> objects. Similar to <code>@QuadConstraint</code>, except it accepts multiple constraints as input as long as they are separated by newlines.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/JuMP.jl/tree/017ddcf6e1ec214dff3a6896d39c13a04b02d5be/src/macros.jl#L753-L757">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.push!-Union{Tuple{C}, Tuple{JuMP.GenericAffExpr{C,V},C,V}, Tuple{V}} where V where C" href="#Base.push!-Union{Tuple{C}, Tuple{JuMP.GenericAffExpr{C,V},C,V}, Tuple{V}} where V where C"><code>Base.push!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">Base.push!{C,V}(aff::GenericAffExpr{C,V}, new_coeff::C, new_var::V)</code></pre><p>An efficient way to grow an affine expression by one term. For example, to add <code>5x</code> to an existing expression <code>aff</code>, use <code>push!(aff, 5.0, x)</code>. This is significantly more efficient than <code>aff += 5.0*x</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/JuMP.jl/tree/017ddcf6e1ec214dff3a6896d39c13a04b02d5be/src/affexpr.jl#L51-L55">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.append!-Union{Tuple{C}, Tuple{JuMP.GenericAffExpr{C,V},JuMP.GenericAffExpr{C,V}}, Tuple{V}} where V where C" href="#Base.append!-Union{Tuple{C}, Tuple{JuMP.GenericAffExpr{C,V},JuMP.GenericAffExpr{C,V}}, Tuple{V}} where V where C"><code>Base.append!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">Base.append!{C,V}(aff::GenericAffExpr{C,V}, other::GenericAffExpr{C,V})</code></pre><p>Efficiently append the terms of an affine expression to an existing affine expression. For example, given <code>aff = 5.0*x</code> and <code>other = 7.0*y + 3.0*z</code>, we can grow <code>aff</code> using <code>append!(aff, other)</code> which results in <code>aff</code> equaling <code>5x + 7y + 3z</code>. This is significantly more efficient than using <code>aff += other</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/JuMP.jl/tree/017ddcf6e1ec214dff3a6896d39c13a04b02d5be/src/affexpr.jl#L63-L67">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.linearterms" href="#JuMP.linearterms"><code>JuMP.linearterms</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">linearterms(aff::GenericAffExpr)</code></pre><p>Provides an iterator over the <code>(a_i::C,x_i::V)</code> terms in affine expression <span>$\sum_i a_i x_i + b$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/JuMP.jl/tree/017ddcf6e1ec214dff3a6896d39c13a04b02d5be/src/affexpr.jl#L40-L44">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.getvalue-Tuple{JuMP.GenericAffExpr{Float64,JuMP.Variable}}" href="#JuMP.getvalue-Tuple{JuMP.GenericAffExpr{Float64,JuMP.Variable}}"><code>JuMP.getvalue</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">getvalue(a::AffExpr)</code></pre><p>Evaluate an <code>AffExpr</code> given the current solution values.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/JuMP.jl/tree/017ddcf6e1ec214dff3a6896d39c13a04b02d5be/src/affexpr.jl#L136-L140">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuMP.getvalue-Tuple{JuMP.GenericQuadExpr{Float64,JuMP.Variable}}" href="#JuMP.getvalue-Tuple{JuMP.GenericQuadExpr{Float64,JuMP.Variable}}"><code>JuMP.getvalue</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">getvalue(a::QuadExpr)</code></pre><p>Evaluate a <code>QuadExpr</code> given the current solution values.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaOpt/JuMP.jl/tree/017ddcf6e1ec214dff3a6896d39c13a04b02d5be/src/quadexpr.jl#L91-L95">source</a><br/></section><h2><a class="nav-anchor" id="Constraint-References-1" href="#Constraint-References-1">Constraint References</a></h2><p>In order to manipulate constraints after creation, it is necessary to maintain a reference. The simplest way to do this is to use the special three-argument named constraint syntax for <code>@constraint</code>, which additionally allows you to create groups of constraints indexed by sets analogously to <code>@variable</code>. For example:</p><pre><code class="language-julia">@variable(m, x[1:3])
@variable(m, y[2:2:6])
@constraint(m, xyconstr[i=1:3,j=6:-2:2], x[i] - y[j] == 1)</code></pre><p>adds 9 constraints to the model <code>m</code> of the expected form. The variable <code>xyconstr</code> is a collection of <code>ConstraintRef{Model,LinearConstraint}</code> instances indexed by the ranges <code>1:3</code> and <code>6:-2:2</code> (the ordered tuple <code>(6,4,2)</code>), so, for example <code>xyconstr[2,4]</code> is a reference to the constraint <code>x[2] - y[4] == 1</code>. Indices can have dependencies on preceding indices, e.g. triangular indexing is allowed:</p><pre><code class="language-julia">@constraint(m, triconstr[i=1:3,j=2i:2:6], x[i] - y[j] == 1)</code></pre><p>A condition can be added following the indices; a semicolon is used to separate index sets from the condition:</p><pre><code class="language-julia">@constraint(m, constr[i=1:5,j=1:5; i+j &gt;= 3], x[i] - y[j] == 1)</code></pre><p>Note that only one condition can be added, although expressions can be built up by using the usual <code>&amp;&amp;</code> and <code>||</code> logical operators.</p><p>Anonymous syntax is supported:</p><pre><code class="language-julia">constr = @constraint(m, [i=1:5,j=1:5; i+j &gt;= 3], x[i] - y[j] == 1)</code></pre><p>To obtain the dual of a constraint, call <code>getdual</code> on the constraint reference:</p><pre><code class="language-julia">println(getdual(xyconstr[1,6]))</code></pre><p>When an LP model is infeasible, <code>getdual</code> will return the corresponding component of the infeasibility ray (Farkas proof), if available from the solver.</p><p>Dual information is also accessible for second-order cone problems as described below. Duals are unavailable for MIPs.</p><p>One may retrieve the corresponding internal <code>LinearConstraint</code> object from a <code>ConstraintRef{Model,LinearConstraint}</code> object <code>constr</code> by calling <code>LinearConstraint(constr)</code>. This functionality is not yet implemented for other classes of constraints.</p><p>For users who prefer to generate constraints in an explicit loop, we also provide the <code>@constraintref</code> convenience macro, e.g.:</p><pre><code class="language-julia">@constraintref constraintName[1:3]</code></pre><p>You can then iterate over constraints and store references in this structure, e.g.:</p><pre><code class="language-julia">@variable(m, x[1:5] &gt;= 0)
@constraintref myCons[1:5]
for i = 1:5
  myCons[i] = @constraint(m, x[i] &gt;= i)
end</code></pre><h2><a class="nav-anchor" id="Conic-constraint-duals-1" href="#Conic-constraint-duals-1">Conic constraint duals</a></h2><p>JuMP supports accessing the dual solutions to second-order cone problems. Dual multipliers on variable bounds, linear constraints, and second-order cone constraints are accessible through <code>getdual()</code> given the corresponding variable or constraint reference object. For second-order cone constraints, <code>getdual(c::ConstraintRef{Model,SOCConstraint})</code> returns a vector of dual variables in the dimension of the corresponding cone. Duals are defined such that they are consistent in sign with linear programming duals in the case that the second-order cone constraints are inactive.</p><p>For example:</p><pre><code class="language-julia">m = Model()
@variable(m, x[1:2] &gt;= 1)
@variable(m, t)
@objective(m, Min, t)
@constraint(m, soc, norm( x[i] for i=1:2 ) &lt;= t)
status = solve(m)

@show getvalue(x) # [1.000000000323643,1.0000000003235763]
@show getvalue(t) # 1.4142135583106126
@show getdual(x)  # [0.7071067807797846,0.7071067802906756]
@show getdual(soc)# [-1.0000000004665652,0.707106779497123,0.707106779008014]</code></pre><p>Note that the <em>negative</em> of the dual vector <code>getdual(soc)</code> belongs to the second-order cone. See the <a href="http://mathprogbasejl.readthedocs.org/en/latest/conic.html">MathProgBase documentation</a> for more on the definition of the dual problem. The dual solutions returned by JuMP agree with the definitions from MathProgBase up to a possible change in sign.</p><h2><a class="nav-anchor" id="Vectorized-operations-1" href="#Vectorized-operations-1">Vectorized operations</a></h2><p>JuMP supports vectorized expressions and constraints for linear and quadratic models. Although this syntax may be familiar for users coming from MATLAB-based modeling languages, we caution that this syntax may be slower than the scalar versions using loops–-especially for large operations. Nevertheless, the syntax often proves useful, for example in constraints involving small, dense matrix-vector products.</p><p>Linear algebraic operators are available to give meaning to expressions like <code>A*x</code> where <code>A</code> is a matrix of numbers and <code>x</code> is a vector of <code>Variable</code> objects. You may also use objects of type <code>Array{Variable}</code> in these kinds of expressions; for example, any object you construct with <code>@variable</code> where each of the index sets are of the form <code>1:n</code>. For example:</p><pre><code class="language-julia">@variable(m, x[1:3,1:4])
expr = rand(3,3)*x</code></pre><p>is allowed, while:</p><pre><code class="language-julia">@variable(m, x[2:4])
expr = rand(3,3)*x</code></pre><p>is not. Addition and subtraction are also defined in similar ways, following the usual Julia rules for linear algebra over arrays.</p><p>Vectorized constraints can be added to the model, using the elementwise comparison operators <code>.==</code>, <code>.&gt;=</code>, and <code>.&lt;=</code>. For instance, you can write constraints of the form:</p><pre><code class="language-julia">@variable(m, x[1:10])
A = rand(5,10)
b = rand(5)
@constraint(m, A*x + b .&lt;= 1)</code></pre><p>Note that scalar literals (such as 1 or 0) are allowed in expressions.</p><p>Concatenation is also possible for these arrays of variables or expressions. For instance, the following will create a matrix of <code>QuadExpr</code> that you can use elsewhere in your model:</p><pre><code class="language-julia">@variable(m, x[1:3])
A = [1 x&#39;
     x x*x&#39;]</code></pre><p>Finally, note that this feature is not currently supported directly in nonlinear expressions; for example, a matrix–vector product will not work inside a call to the <code>@NLconstraint</code> macro.</p><footer><hr/><a class="previous" href="refvariable.html"><span class="direction">Previous</span><span class="title">Variables</span></a><a class="next" href="probmod.html"><span class="direction">Next</span><span class="title">Problem Modification</span></a></footer></article></body></html>
