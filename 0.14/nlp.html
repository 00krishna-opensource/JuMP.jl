

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Nonlinear Modeling &mdash; JuMP -- Julia for Mathematical Optimization 0.14 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="JuMP -- Julia for Mathematical Optimization 0.14 documentation" href="index.html"/>
        <link rel="prev" title="Solver Callbacks" href="callbacks.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> JuMP -- Julia for Mathematical Optimization
          

          
          </a>

          
            
            
              <div class="version">
                0.14
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="quickstart.html">Quick Start Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="refmodel.html">Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="refvariable.html">Variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="refexpr.html">Expressions and Constraints</a></li>
<li class="toctree-l1"><a class="reference internal" href="probmod.html">Problem Modification</a></li>
<li class="toctree-l1"><a class="reference internal" href="callbacks.html">Solver Callbacks</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="">Nonlinear Modeling</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#syntax-notes">Syntax notes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#nonlinear-parameters">Nonlinear Parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="#user-defined-functions">User-defined functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#factors-affecting-solution-time">Factors affecting solution time</a></li>
<li class="toctree-l2"><a class="reference internal" href="#querying-derivatives-from-a-jump-model">Querying derivatives from a JuMP model</a></li>
<li class="toctree-l2"><a class="reference internal" href="#raw-expression-input">Raw expression input</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">JuMP -- Julia for Mathematical Optimization</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>Nonlinear Modeling</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/nlp.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div id="officialwarn" class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This documentation tracks the development branch of JuMP. For the documentation of the latest JuMP release, see <a href="http://www.juliaopt.org/JuMP.jl/0.14/">here</a>.</p>
</div>
<script type="text/javascript">
if(!(location.hostname.match('readthedocs') || location.hostname.match('rtfd'))){
    document.getElementById("officialwarn").style.display = 'none';
}
</script><div class="section" id="nonlinear-modeling">
<h1>Nonlinear Modeling<a class="headerlink" href="#nonlinear-modeling" title="Permalink to this headline">Â¶</a></h1>
<p>JuMP has support for general smooth nonlinear (convex and
nonconvex) optimization problems. JuMP is able to provide exact, sparse second-order
derivatives to solvers. This information can improve solver accuracy and
performance.</p>
<p>Nonlinear objectives and constraints are specified by using the <code class="docutils literal"><span class="pre">&#64;NLobjective</span></code>
and <code class="docutils literal"><span class="pre">&#64;NLconstraint</span></code> macros. The familiar <code class="docutils literal"><span class="pre">sum{}</span></code> syntax is supported within
these macros, as well as <code class="docutils literal"><span class="pre">prod{}</span></code> which analogously represents the product of
the terms within. Note that the <code class="docutils literal"><span class="pre">&#64;objective</span></code> and <code class="docutils literal"><span class="pre">&#64;constraint</span></code>
macros (and corresponding functions) do <em>not</em> currently support nonlinear expressions.
However, a model can contain a mix of linear, quadratic, and nonlinear constraints or
objective functions.  Starting points may be provided by using the <code class="docutils literal"><span class="pre">start</span></code>
keyword argument to <code class="docutils literal"><span class="pre">&#64;variable</span></code>.
If a starting value is not provided for a variable, it will be set to the projection
of zero onto the interval defined by the variable bounds.
For nonconvex problems, the returned solution is only guaranteed to be
locally optimal. Convexity detection is not currently provided.</p>
<p>For example, we can solve the classical Rosenbrock problem (with a twist) as follows:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="k">using</span> <span class="n">JuMP</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">Model</span><span class="p">()</span>
<span class="p">@</span><span class="n">variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">start</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">)</span>
<span class="p">@</span><span class="n">variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">start</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">)</span>

<span class="p">@</span><span class="n">NLobjective</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">Min</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">100</span><span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span>

<span class="n">solve</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="n">println</span><span class="p">(</span><span class="s">&quot;x = &quot;</span><span class="p">,</span> <span class="n">getvalue</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="s">&quot; y = &quot;</span><span class="p">,</span> <span class="n">getvalue</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>

<span class="c"># adding a (linear) constraint</span>
<span class="p">@</span><span class="n">constraint</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">10</span><span class="p">)</span>
<span class="n">solve</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="n">println</span><span class="p">(</span><span class="s">&quot;x = &quot;</span><span class="p">,</span> <span class="n">getvalue</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="s">&quot; y = &quot;</span><span class="p">,</span> <span class="n">getvalue</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
</pre></div>
</div>
<p>Examples: <a class="reference external" href="https://github.com/JuliaOpt/JuMP.jl/blob/master/examples/optcontrol.jl">optimal control</a>, <a class="reference external" href="https://github.com/JuliaOpt/JuMP.jl/blob/master/examples/mle.jl">maximum likelihood estimation</a>, and  <a class="reference external" href="https://github.com/JuliaOpt/JuMP.jl/tree/master/test/hockschittkowski">Hock-Schittkowski tests</a>.</p>
<div class="section" id="syntax-notes">
<h2>Syntax notes<a class="headerlink" href="#syntax-notes" title="Permalink to this headline">Â¶</a></h2>
<p>The syntax accepted in nonlinear expressions is more restricted than
the syntax for linear and quadratic expressions. We note some important points below.</p>
<ul>
<li><p class="first">All expressions must be simple scalar operations. You cannot use <code class="docutils literal"><span class="pre">dot</span></code>,
matrix-vector products, vector slices, etc. Translate vector operations
into explicit <code class="docutils literal"><span class="pre">sum{}</span></code> operations or use the <code class="docutils literal"><span class="pre">AffExpr</span></code> plus auxiliary variable
trick described below.</p>
</li>
<li><p class="first">There is no operator overloading provided to build up nonlinear expressions.
For example, if <code class="docutils literal"><span class="pre">x</span></code> is a JuMP variable, the code <code class="docutils literal"><span class="pre">3x</span></code> will return an
<code class="docutils literal"><span class="pre">AffExpr</span></code> object that can be used inside of future expressions and
linear constraints.
However, the code <code class="docutils literal"><span class="pre">sin(x)</span></code> is an error. All nonlinear expressions must
be inside of macros.</p>
</li>
<li><p class="first">As a corollary, user-defined functions may not be used within nonlinear
expressions. See the example below:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">myfunction</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">b</span>
<span class="p">@</span><span class="n">variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span> <span class="p">@</span><span class="n">variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="p">@</span><span class="n">NLobjective</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">Min</span><span class="p">,</span> <span class="n">myfunction</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">))</span> <span class="c"># ERROR</span>
<span class="p">@</span><span class="n">NLobjective</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">Min</span><span class="p">,</span> <span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">y</span><span class="p">)</span> <span class="c"># Okay</span>
</pre></div>
</div>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">AffExpr</span></code> and <code class="docutils literal"><span class="pre">QuadExpr</span></code> objects cannot currently be used inside nonlinear
expressions. Instead, introduce auxiliary variables, e.g.:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">myexpr</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span><span class="n">y</span> <span class="c"># where x and y are variables</span>
<span class="p">@</span><span class="n">variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">aux</span><span class="p">)</span>
<span class="p">@</span><span class="n">constraint</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">aux</span> <span class="o">==</span> <span class="n">myexpr</span><span class="p">)</span>
<span class="p">@</span><span class="n">NLobjective</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">Min</span><span class="p">,</span> <span class="n">sin</span><span class="p">(</span><span class="n">aux</span><span class="p">))</span>
</pre></div>
</div>
</li>
<li><p class="first">You can declare embeddable nonlinear expressions with <code class="docutils literal"><span class="pre">&#64;NLexpression</span></code>. For example:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="p">@</span><span class="n">NLexpression</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">myexpr</span><span class="p">[</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="p">],</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
<span class="p">@</span><span class="n">NLconstraint</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">myconstr</span><span class="p">[</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="p">],</span> <span class="n">myexpr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first">Anonymous syntax is supported in <code class="docutils literal"><span class="pre">&#64;NLexpression</span></code> and <code class="docutils literal"><span class="pre">&#64;NLconstraint</span></code>:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">myexpr</span> <span class="o">=</span> <span class="p">@</span><span class="n">NLexpression</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="p">[</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="p">],</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
<span class="n">myconstr</span> <span class="o">=</span> <span class="p">@</span><span class="n">NLconstraint</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="p">[</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="p">],</span> <span class="n">myexpr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="nonlinear-parameters">
<span id="nonlinearprobmod"></span><h2>Nonlinear Parameters<a class="headerlink" href="#nonlinear-parameters" title="Permalink to this headline">Â¶</a></h2>
<p>For nonlinear models only, JuMP offers a syntax for explicit &#8220;parameter&#8221; objects
which can be used to modify a model in-place just by updating the value of
the parameter.
Nonlinear parameters are declared by using the <code class="docutils literal"><span class="pre">&#64;NLparameter</span></code> macro and may
be indexed by arbitrary sets analogously to JuMP variables and expressions.
The initial value of the parameter must be provided
on the right-hand side of the <code class="docutils literal"><span class="pre">==</span></code> sign as seen below:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="p">@</span><span class="n">NLparameter</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">10</span><span class="p">)</span>
<span class="p">@</span><span class="n">NLparameter</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="mi">10</span><span class="p">]</span> <span class="o">==</span> <span class="n">my_data</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="c"># set of parameters indexed from 1 to 10</span>
</pre></div>
</div>
<p>You may use <code class="docutils literal"><span class="pre">getvalue</span></code> and <code class="docutils literal"><span class="pre">setvalue</span></code> to query or update the value of a parameter:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">getvalue</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="c"># 10, from above</span>
<span class="n">setvalue</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mf">54.3</span><span class="p">)</span> <span class="c"># y[4] now holds the value 54.3</span>
</pre></div>
</div>
<p>Nonlinear parameters can be used <em>within nonlinear expressions</em> only:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="p">@</span><span class="n">variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="p">@</span><span class="n">objective</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">Max</span><span class="p">,</span> <span class="n">x</span><span class="o">*</span><span class="n">z</span><span class="p">)</span>       <span class="c"># error: x is a nonlinear parameter</span>
<span class="p">@</span><span class="n">NLobjective</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">Max</span><span class="p">,</span> <span class="n">x</span><span class="o">*</span><span class="n">z</span><span class="p">)</span>     <span class="c"># ok</span>
<span class="p">@</span><span class="n">expression</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">my_expr</span><span class="p">,</span> <span class="n">x</span><span class="o">*</span><span class="n">z</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span>      <span class="c"># error: x is a nonlinear parameter</span>
<span class="p">@</span><span class="n">NLexpression</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">my_nl_expr</span><span class="p">,</span> <span class="n">x</span><span class="o">*</span><span class="n">z</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span> <span class="c"># ok</span>
</pre></div>
</div>
<p>Nonlinear parameters are useful when solving nonlinear models in a sequence:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">m</span> <span class="o">=</span> <span class="n">Model</span><span class="p">()</span>
<span class="p">@</span><span class="n">variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="p">@</span><span class="n">NLparameter</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">x</span> <span class="o">==</span> <span class="mf">1.0</span><span class="p">)</span>
<span class="p">@</span><span class="n">NLobjective</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">Min</span><span class="p">,</span> <span class="p">(</span><span class="n">z</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span>
<span class="n">solve</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="n">getvalue</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="c"># equals 1.0</span>

<span class="c"># Now, update the value of x to solve a different problem</span>
<span class="n">setvalue</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">)</span>
<span class="n">solve</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="n">getvalue</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="c"># equals 5.0</span>
</pre></div>
</div>
<p>Using nonlinear parameters can be faster than creating a new model from scratch
with updated data because JuMP is able to avoid repeating a number of steps
in processing the model before handing it off to the solver.</p>
</div>
<div class="section" id="user-defined-functions">
<h2>User-defined functions<a class="headerlink" href="#user-defined-functions" title="Permalink to this headline">Â¶</a></h2>
<p>JuMP&#8217;s library of recognized univariate functions is derived from the <a class="reference external" href="https://github.com/johnmyleswhite/Calculus.jl">Calculus.jl</a> package. If you encounter a standard special function not currently supported by JuMP, consider contributing to the <a class="reference external" href="https://github.com/johnmyleswhite/Calculus.jl/blob/cb42f3699177449a42bdc3461c8aea8777aa8c39/src/differentiate.jl#L115">list of derivative rules</a> there. In addition to this built-in list of functions, it is possible to register custom (<em>user-defined</em>) nonlinear functions to use within nonlinear expressions. JuMP does not support black-box optimization, so all user-defined functions must provide derivatives in some form. Fortunately, JuMP supports <strong>automatic differentiation of user-defined functions</strong>, a feature to our knowledge not available in any comparable modeling systems.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Automatic differentiation is <em>not</em> finite differencing. JuMP&#8217;s automatically computed derivatives are not subject to approximation error.</p>
</div>
<p>JuMP uses <a class="reference external" href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> to perform automatic differentiation; see the ForwardDiff.jl <a class="reference external" href="http://www.juliadiff.org/ForwardDiff.jl/perf_diff.html#restrictions-on-the-target-function">documentation</a> for a description of how to write a function suitable for automatic differentiation. The general guideline is to write code that is generic with respect to the number type; don&#8217;t assume that the input to the function is <code class="docutils literal"><span class="pre">Float64</span></code>. To register a user-defined function with derivatives computed by automatic differentiation, use the <code class="docutils literal"><span class="pre">JuMP.register</span></code> method as in the following example:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">mysquare</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span><span class="o">^</span><span class="mi">2</span>
<span class="n">myf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span>

<span class="n">JuMP</span><span class="o">.</span><span class="n">register</span><span class="p">(:</span><span class="n">myf</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">myf</span><span class="p">,</span> <span class="n">autodiff</span><span class="o">=</span><span class="n">true</span><span class="p">)</span>
<span class="n">JuMP</span><span class="o">.</span><span class="n">register</span><span class="p">(:</span><span class="n">mysquare</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">mysquare</span><span class="p">,</span> <span class="n">autodiff</span><span class="o">=</span><span class="n">true</span><span class="p">)</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">Model</span><span class="p">()</span>

<span class="p">@</span><span class="n">variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="p">@</span><span class="n">NLobjective</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">Min</span><span class="p">,</span> <span class="n">myf</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">mysquare</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])))</span>
</pre></div>
</div>
<p>The above code creates a JuMP model with the objective function <code class="docutils literal"><span class="pre">(x[1]-1)^2</span> <span class="pre">+</span> <span class="pre">(x[2]^2-2)^2</span></code>. The first argument to <code class="docutils literal"><span class="pre">JuMP.register</span></code> is a Julia symbol object which registers the name of the user-defined function in JuMP expressions; the JuMP name need not be the same as the name of the corresponding Julia method. The second argument specifies how many arguments the function takes. The third argument is the name of the Julia method which computes the function, and <code class="docutils literal"><span class="pre">autodiff=true</span></code> instructs JuMP to compute exact gradients automatically.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">All arguments to user-defined functions are scalars, not vectors. To define a function which takes a large number of arguments, you may use the splatting syntax <code class="docutils literal"><span class="pre">f(x...)</span> <span class="pre">=</span> <span class="pre">...</span></code>.</p>
</div>
<p>Forward-mode automatic differentiation as implemented by ForwardDiff.jl has a computational cost that scales linearly with the number of input dimensions. As such, it is not the most efficient way to compute gradients of user-defined functions if the number of input arguments is large. In this case, users may want to provide their own routines for evaluating gradients. The more general syntax for <code class="docutils literal"><span class="pre">JuMP.register</span></code> which accepts user-provided derivative evaluation routines is:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">JuMP</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">s</span><span class="p">::</span><span class="n">Symbol</span><span class="p">,</span> <span class="n">dimension</span><span class="p">::</span><span class="n">Integer</span><span class="p">,</span> <span class="n">f</span><span class="p">::</span><span class="n">Function</span><span class="p">,</span> <span class="n">âf</span><span class="p">::</span><span class="n">Function</span><span class="p">,</span> <span class="n">âÂ²f</span><span class="p">::</span><span class="n">Function</span><span class="p">)</span>
</pre></div>
</div>
<p>The input differs for functions which take a single input argument and functions which take more than one. For univariate functions, the derivative evaluation routines should return a number which represents the first and second-order derivatives respectively. For multivariate functions, the derivative evaluation routines will be passed a gradient vector which they must explicitly fill. Second-order derivatives of multivariate functions are not currently supported; this argument should be omitted. The following example sets up the same optimization problem as before, but now we explicitly provide evaluation routines for the user-defined functions:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">mysquare</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span><span class="o">^</span><span class="mi">2</span>
<span class="n">mysquare_prime</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="mi">2</span><span class="n">x</span>
<span class="n">mysquare_primeprime</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">myf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span>
<span class="k">function</span><span class="nf"> </span><span class="o">â</span><span class="n">f</span><span class="p">(</span><span class="n">g</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
    <span class="n">g</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">g</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="k">end</span>

<span class="n">JuMP</span><span class="o">.</span><span class="n">register</span><span class="p">(:</span><span class="n">myf</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">myf</span><span class="p">,</span> <span class="n">âf</span><span class="p">)</span>
<span class="n">JuMP</span><span class="o">.</span><span class="n">register</span><span class="p">(:</span><span class="n">mysquare</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">mysquare</span><span class="p">,</span> <span class="n">mysquare_prime</span><span class="p">,</span> <span class="n">mysquare_primeprime</span><span class="p">)</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">Model</span><span class="p">()</span>

<span class="p">@</span><span class="n">variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="p">@</span><span class="n">NLobjective</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">Min</span><span class="p">,</span> <span class="n">myf</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">mysquare</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])))</span>
</pre></div>
</div>
<p>Support for user-provided functions was recently introduced in JuMP 0.12 and is not mature. Please let us know if you find any important functionality missing.</p>
</div>
<div class="section" id="factors-affecting-solution-time">
<h2>Factors affecting solution time<a class="headerlink" href="#factors-affecting-solution-time" title="Permalink to this headline">Â¶</a></h2>
<p>The execution time when solving a nonlinear programming problem can be divided into two parts, the time spent in the optimization algorithm (the solver) and the time spent evaluating the nonlinear functions and corresponding derivatives. Ipopt explicitly displays these two timings in its output, for example:</p>
<div class="highlight-text"><div class="highlight"><pre>Total CPU secs in IPOPT (w/o function evaluations)   =      7.412
Total CPU secs in NLP function evaluations           =      2.083
</pre></div>
</div>
<p>For Ipopt in particular, one can improve the performance by installing advanced sparse linear algebra packages, see <span class="xref std std-ref">jump-installation</span>. For other solvers, see their respective documentation for performance tips.</p>
<p>The function evaluation time, on the other hand, is the responsibility of the modeling language. JuMP computes derivatives by using the <a class="reference external" href="https://github.com/mlubin/ReverseDiffSparse.jl">ReverseDiffSparse</a> package, which implements, in pure Julia, reverse-mode automatic differentiation with graph coloring methods for exploiting sparsity of the Hessian matrix <a class="footnote-reference" href="#id2" id="id1">[1]</a>. As a conservative bound, JuMP&#8217;s performance here currently may be expected to be within a factor of 5 of AMPL&#8217;s.</p>
</div>
<div class="section" id="querying-derivatives-from-a-jump-model">
<h2>Querying derivatives from a JuMP model<a class="headerlink" href="#querying-derivatives-from-a-jump-model" title="Permalink to this headline">Â¶</a></h2>
<p>For some advanced use cases, one may want to directly query the derivatives
of a JuMP model instead of handing the problem off to a solver.
Internally, JuMP implements the <code class="docutils literal"><span class="pre">AbstractNLPEvaluator</span></code> interface from
<a class="reference external" href="http://mathprogbasejl.readthedocs.org/en/latest/nlp.html">MathProgBase</a>.
To obtain an NLP evaluator object from a JuMP model, use <code class="docutils literal"><span class="pre">JuMP.NLPEvaluator</span></code>.
The <code class="docutils literal"><span class="pre">linearindex</span></code> method maps from JuMP variables to the variable
indices at the MathProgBase level.</p>
<p>For example:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">m</span> <span class="o">=</span> <span class="n">Model</span><span class="p">()</span>
<span class="p">@</span><span class="n">variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="p">@</span><span class="n">variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

<span class="p">@</span><span class="n">NLobjective</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">Min</span><span class="p">,</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
<span class="n">values</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">values</span><span class="p">[</span><span class="n">linearindex</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">2.0</span>
<span class="n">values</span><span class="p">[</span><span class="n">linearindex</span><span class="p">(</span><span class="n">y</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">3.0</span>

<span class="n">d</span> <span class="o">=</span> <span class="n">JuMP</span><span class="o">.</span><span class="n">NLPEvaluator</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="n">MathProgBase</span><span class="o">.</span><span class="n">initialize</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="p">[:</span><span class="n">Grad</span><span class="p">])</span>
<span class="n">objval</span> <span class="o">=</span> <span class="n">MathProgBase</span><span class="o">.</span><span class="n">eval_f</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span> <span class="c"># == sin(2.0) + sin(3.0)</span>

<span class="n">âf</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">MathProgBase</span><span class="o">.</span><span class="n">eval_grad_f</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">âf</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
<span class="c"># âf[linearindex(x)] == cos(2.0)</span>
<span class="c"># âf[linearindex(y)] == cos(3.0)</span>
</pre></div>
</div>
<p>The ordering of constraints in a JuMP model corresponds to the following ordering
at the MathProgBase nonlinear abstraction layer. There are three groups of constraints:
linear, quadratic, and nonlinear. Linear and quadratic constraints, to be recognized
as such, must be added with the <code class="docutils literal"><span class="pre">&#64;constraint</span></code> macros. All constraints added with
the <code class="docutils literal"><span class="pre">&#64;NLconstraint</span></code> macros are treated as nonlinear constraints.
Linear constraints are ordered first, then quadratic, then nonlinear.
The <code class="docutils literal"><span class="pre">linearindex</span></code> method applied to a constraint reference object
returns the index of the constraint <em>within its corresponding constraint class</em>.
For example:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">m</span> <span class="o">=</span> <span class="n">Model</span><span class="p">()</span>
<span class="p">@</span><span class="n">variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="p">@</span><span class="n">constraint</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">cons1</span><span class="p">,</span> <span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">@</span><span class="n">constraint</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">cons2</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
<span class="p">@</span><span class="n">NLconstraint</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">cons3</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">5</span> <span class="o">==</span> <span class="mi">10</span><span class="p">)</span>

<span class="nb">typeof</span><span class="p">(</span><span class="n">cons1</span><span class="p">)</span> <span class="c"># JuMP.ConstraintRef{JuMP.Model,JuMP.GenericQuadConstraint{JuMP.GenericQuadExpr{Float64,JuMP.Variable}}} indicates a quadratic constraint</span>
<span class="nb">typeof</span><span class="p">(</span><span class="n">cons2</span><span class="p">)</span> <span class="c"># JuMP.ConstraintRef{JuMP.Model,JuMP.GenericRangeConstraint{JuMP.GenericAffExpr{Float64,JuMP.Variable}}} indicates a linear constraint</span>
<span class="nb">typeof</span><span class="p">(</span><span class="n">cons3</span><span class="p">)</span> <span class="c"># JuMP.ConstraintRef{JuMP.Model,JuMP.GenericRangeConstraint{JuMP.NonlinearExprData}} indicates a nonlinear constraint</span>
<span class="n">linearindex</span><span class="p">(</span><span class="n">cons1</span><span class="p">)</span> <span class="o">==</span> <span class="n">linearindex</span><span class="p">(</span><span class="n">cons2</span><span class="p">)</span> <span class="o">==</span> <span class="n">linearindex</span><span class="p">(</span><span class="n">cons3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
</pre></div>
</div>
<p>When querying derivatives, <code class="docutils literal"><span class="pre">cons2</span></code> will appear first, because it is the first linear constraint, then <code class="docutils literal"><span class="pre">cons1</span></code>, because it is the first quadratic constraint, then <code class="docutils literal"><span class="pre">cons3</span></code>, because it is the first nonlinear constraint. Note that for one-sided nonlinear constraints, JuMP subtracts any values on the right-hand side when computing expressions. In other words, one-sided nonlinear constraints are always transformed to have a right-hand side of zero.</p>
<p>The <code class="docutils literal"><span class="pre">JuMP.constraintbounds(m::Model)</span></code> method returns the lower and upper bounds
of all the constraints in the model, concatenated in the order discussed above.</p>
<p>This method of querying derivatives directly from a JuMP model is convenient for
interacting with the model in a structured way, e.g., for accessing derivatives of
specific variables. For example, in statistical maximum likelihood estimation problems,
one is often interested in the Hessian matrix at the optimal solution,
which can be queried using the <code class="docutils literal"><span class="pre">JuMP.NLPEvaluator</span></code>.</p>
<p>If you are writing a &#8220;solver&#8221;, we <em>highly encourage</em> use of the <a class="reference external" href="http://mathprogbasejl.readthedocs.org/en/latest/nlp.html">MathProgBase nonlinear interface</a> over querying derivatives using the above methods. These methods are provided for convenience but do not fully integrate with JuMP&#8217;s solver infrastructure. In particular, they do not allow users to specify your solver to the <code class="docutils literal"><span class="pre">Model()</span></code> constructor nor to call it using <code class="docutils literal"><span class="pre">solve()</span></code> nor to populate the solution back into the model. Use of the MathProgBase interface also has the advantage of being independent of JuMP itself; users of MathProgBase solvers are free to implement their own evaluation routines instead of expressing their model in JuMP.  You may use the <code class="docutils literal"><span class="pre">JuMP.build</span></code> method to ask JuMP to populate the &#8220;solver&#8221; without calling <code class="docutils literal"><span class="pre">optimize!</span></code>.</p>
</div>
<div class="section" id="raw-expression-input">
<h2>Raw expression input<a class="headerlink" href="#raw-expression-input" title="Permalink to this headline">Â¶</a></h2>
<p>In addition to the <code class="docutils literal"><span class="pre">&#64;NLobjective</span></code> and <code class="docutils literal"><span class="pre">&#64;NLconstraint</span></code> macros, it is also
possible to provide Julia <code class="docutils literal"><span class="pre">Expr</span></code> objects directly by using
<code class="docutils literal"><span class="pre">JuMP.setNLobjective</span></code> and <code class="docutils literal"><span class="pre">JuMP.addNLconstraint</span></code>. This input form
may be useful if the expressions are generated programmatically.
JuMP variables should be spliced into the expression object. For example:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="p">@</span><span class="n">variable</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">JuMP</span><span class="o">.</span><span class="n">setNLobjective</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="p">:</span><span class="n">Min</span><span class="p">,</span> <span class="p">:(</span><span class="o">$</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">*$</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="o">$</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">+$</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">+$</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span> <span class="o">+</span> <span class="o">$</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">])))</span>
<span class="n">JuMP</span><span class="o">.</span><span class="n">addNLconstraint</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="p">:(</span><span class="o">$</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">*$</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">*$</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="o">*$</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="mi">25</span><span class="p">))</span>

<span class="c"># Equivalent form using traditional JuMP macros:</span>
<span class="p">@</span><span class="n">NLobjective</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">Min</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="p">@</span><span class="n">NLconstraint</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">25</span><span class="p">)</span>
</pre></div>
</div>
<p>See the Julia documentation for more examples and description of Julia expressions.</p>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Dunning, Huchette, and Lubin, &#8220;JuMP: A Modeling Language for Mathematical Optimization&#8221;, <a class="reference external" href="http://arxiv.org/abs/1508.01982">arXiv</a>.</td></tr>
</tbody>
</table>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="callbacks.html" class="btn btn-neutral" title="Solver Callbacks" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, Miles Lubin, Iain Dunning, and Joey Huchette.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.14',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
  
 
<!-- Google Analytics -->
<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-44252521-1', 'auto');
ga('send', 'pageview');
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>
<!-- End Google Analytics -->


</body>
</html>